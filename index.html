<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Viral Video Maker</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-purple-900 via-gray-900 to-black text-white min-h-screen">
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        function ViralVideoMaker() {
            const [scenes, setScenes] = useState([
                { id: 1, startTime: 0, endTime: 5, text: 'ƒ∞lk sahne - AI ile g√∂rsel olu≈ütur', imageUrl: '' }
            ]);
            const [currentScene, setCurrentScene] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [isGenerating, setIsGenerating] = useState(false);
            
            const intervalRef = useRef(null);
            const fileInputRef = useRef(null);

            const handleImageUpload = (sceneId, event) => {
                const file = event.target.files?.[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setScenes(prev => prev.map(s => 
                            s.id === sceneId ? { ...s, imageUrl: e.target.result } : s
                        ));
                    };
                    reader.readAsDataURL(file);
                }
            };

            const searchImage = async (sceneId) => {
                const scene = scenes.find(s => s.id === sceneId);
                if (!scene || !scene.text.trim()) {
                    alert('‚ùå L√ºtfen √∂nce metin yazƒ±n!');
                    return;
                }

                setIsGenerating(true);

                try {
                    console.log('üöÄ AI g√∂rsel olu≈üturuluyor...');
                    
                    const promptResponse = await fetch("https://api.anthropic.com/v1/messages", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            model: "claude-sonnet-4-20250514",
                            max_tokens: 500,
                            messages: [{
                                role: "user",
                                content: `Bu T√ºrk√ße metin i√ßin profesyonel bir g√∂rsel tanƒ±mla. ƒ∞ngilizce, detaylƒ±, maksimum 50 kelime.

Metin: "${scene.text}"

G√∂rsel Tanƒ±mƒ±:`
                            }]
                        })
                    });

                    const promptData = await promptResponse.json();
                    const imagePrompt = promptData.content[0].text.trim();
                    
                    console.log('üé® G√∂rsel Prompt:', imagePrompt);
                    alert(`üé® AI g√∂rsel olu≈üturuyor...\n\nPrompt: "${imagePrompt}"\n\n‚è≥ L√ºtfen bekleyin!`);
                    
                    const hfResponse = await fetch(
                        "https://api-inference.huggingface.co/models/stabilityai/stable-diffusion-xl-base-1.0",
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                inputs: imagePrompt,
                                parameters: {
                                    width: 768,
                                    height: 1344,
                                    num_inference_steps: 30
                                }
                            })
                        }
                    );

                    if (!hfResponse.ok) {
                        throw new Error(`API hatasƒ±: ${hfResponse.status}`);
                    }

                    const blob = await hfResponse.blob();
                    const reader = new FileReader();
                    
                    reader.onloadend = () => {
                        setScenes(prev => prev.map(s => 
                            s.id === sceneId ? { ...s, imageUrl: reader.result } : s
                        ));
                        alert('‚úÖ AI g√∂rsel ba≈üarƒ±yla olu≈üturuldu!');
                        setIsGenerating(false);
                    };
                    
                    reader.onerror = () => {
                        throw new Error('G√∂rsel okuma hatasƒ±');
                    };
                    
                    reader.readAsDataURL(blob);
                    
                } catch (error) {
                    console.error('‚ùå Hata:', error);
                    alert(`‚ùå G√∂rsel olu≈üturulamadƒ±!\n\n${error.message}`);
                    setIsGenerating(false);
                }
            };

            const addScene = () => {
                const lastScene = scenes[scenes.length - 1];
                setScenes([...scenes, {
                    id: Date.now(),
                    startTime: lastScene.endTime,
                    endTime: lastScene.endTime + 5,
                    text: '',
                    imageUrl: ''
                }]);
            };

            const deleteScene = (id) => {
                if (scenes.length > 1) {
                    setScenes(scenes.filter(s => s.id !== id));
                }
            };

            const updateScene = (id, field, value) => {
                setScenes(scenes.map(s => 
                    s.id === id ? { ...s, [field]: value } : s
                ));
            };

            const togglePlay = () => {
                if (isPlaying) {
                    setIsPlaying(false);
                    window.speechSynthesis.cancel();
                    if (intervalRef.current) clearInterval(intervalRef.current);
                } else {
                    setIsPlaying(true);
                    playTimeline();
                }
            };

            const playTimeline = () => {
                let time = currentTime;
                let lastScene = -1;
                
                intervalRef.current = setInterval(() => {
                    time += 0.1;
                    setCurrentTime(time);
                    
                    const activeIndex = scenes.findIndex(s => 
                        time >= s.startTime && time < s.endTime
                    );
                    
                    if (activeIndex !== -1) {
                        setCurrentScene(activeIndex);
                        
                        if (activeIndex !== lastScene && scenes[activeIndex].text) {
                            lastScene = activeIndex;
                            window.speechSynthesis.cancel();
                            
                            const utterance = new SpeechSynthesisUtterance(scenes[activeIndex].text);
                            utterance.lang = 'tr-TR';
                            utterance.rate = 1.1;
                            window.speechSynthesis.speak(utterance);
                        }
                    }
                    
                    const totalDuration = scenes[scenes.length - 1].endTime;
                    if (time >= totalDuration) {
                        setIsPlaying(false);
                        setCurrentTime(0);
                        setCurrentScene(0);
                        window.speechSynthesis.cancel();
                        clearInterval(intervalRef.current);
                    }
                }, 100);
            };

            useEffect(() => {
                return () => {
                    if (intervalRef.current) clearInterval(intervalRef.current);
                    window.speechSynthesis.cancel();
                };
            }, []);

            const exportProject = () => {
                const dataStr = JSON.stringify(scenes, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'viral-video.json';
                link.click();
                URL.revokeObjectURL(url);
            };

            const totalDuration = scenes[scenes.length - 1]?.endTime || 0;

            return (
                <div className="p-6 max-w-7xl mx-auto">
                    <h1 className="text-4xl font-bold mb-2 bg-gradient-to-r from-pink-500 to-purple-500 bg-clip-text text-transparent">
                        üé¨ AI Viral Video Maker
                    </h1>
                    <p className="text-gray-400 mb-8">AI destekli g√∂rsel olu≈üturucu</p>

                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div className="lg:col-span-1">
                            <div className="bg-gray-800 rounded-lg p-4 border border-purple-500/30">
                                <h2 className="text-xl font-bold mb-4">√ñnizleme</h2>
                                
                                <div className="aspect-[9/16] bg-gray-900 rounded-lg mb-4 overflow-hidden relative">
                                    {scenes[currentScene]?.imageUrl ? (
                                        <img 
                                            src={scenes[currentScene].imageUrl}
                                            alt="G√∂rsel"
                                            className="w-full h-full object-cover"
                                        />
                                    ) : (
                                        <div className="w-full h-full flex items-center justify-center text-gray-500">
                                            G√∂rsel yok
                                        </div>
                                    )}
                                    
                                    {isPlaying && scenes[currentScene]?.text && (
                                        <div className="absolute bottom-4 left-4 right-4 bg-black/70 rounded p-2">
                                            <p className="text-sm text-white">{scenes[currentScene].text}</p>
                                        </div>
                                    )}
                                    
                                    <div className="absolute top-4 right-4 bg-black/70 rounded px-2 py-1 text-sm">
                                        {currentScene + 1} / {scenes.length}
                                    </div>
                                </div>

                                <div className="space-y-3">
                                    <div className="flex items-center gap-2 text-sm">
                                        <span>{currentTime.toFixed(1)}s</span>
                                        <div className="flex-1 h-2 bg-gray-700 rounded-full overflow-hidden">
                                            <div 
                                                className="h-full bg-purple-500"
                                                style={{ width: `${(currentTime / totalDuration) * 100}%` }}
                                            />
                                        </div>
                                        <span>{totalDuration}s</span>
                                    </div>

                                    <button
                                        onClick={togglePlay}
                                        className="w-full bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 py-3 rounded-lg font-bold"
                                    >
                                        {isPlaying ? '‚è∏ Duraklat' : '‚ñ∂ Oynat'}
                                    </button>

                                    <button onClick={exportProject} className="w-full bg-green-600 hover:bg-green-700 py-2 rounded text-sm">
                                        üíæ Export JSON
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div className="lg:col-span-2">
                            <div className="flex items-center justify-between mb-4">
                                <h2 className="text-2xl font-bold">Sahneler</h2>
                                <button onClick={addScene} className="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded">
                                    ‚ûï Sahne Ekle
                                </button>
                            </div>

                            <div className="space-y-4 max-h-[600px] overflow-y-auto">
                                {scenes.map((scene, index) => (
                                    <div 
                                        key={scene.id}
                                        className={`bg-gray-800 rounded-lg p-4 border-2 ${currentScene === index ? 'border-purple-500' : 'border-gray-700'}`}
                                    >
                                        <div className="flex items-center justify-between mb-3">
                                            <span className="font-bold text-purple-400">Sahne {index + 1}</span>
                                            <button 
                                                onClick={() => deleteScene(scene.id)} 
                                                disabled={scenes.length === 1} 
                                                className="text-red-400 hover:text-red-500"
                                            >
                                                üóëÔ∏è
                                            </button>
                                        </div>

                                        <div className="grid grid-cols-2 gap-3 mb-3">
                                            <div>
                                                <label className="text-xs text-gray-400 block mb-1">Ba≈ülangƒ±√ß (sn)</label>
                                                <input 
                                                    type="number" 
                                                    value={scene.startTime} 
                                                    onChange={(e) => updateScene(scene.id, 'startTime', parseFloat(e.target.value))} 
                                                    className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2" 
                                                    step="0.5" 
                                                />
                                            </div>
                                            <div>
                                                <label className="text-xs text-gray-400 block mb-1">Biti≈ü (sn)</label>
                                                <input 
                                                    type="number" 
                                                    value={scene.endTime} 
                                                    onChange={(e) => updateScene(scene.id, 'endTime', parseFloat(e.target.value))} 
                                                    className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2" 
                                                    step="0.5" 
                                                />
                                            </div>
                                        </div>

                                        <div className="mb-3">
                                            <label className="text-xs text-gray-400 block mb-1">TTS Metni</label>
                                            <textarea 
                                                value={scene.text} 
                                                onChange={(e) => updateScene(scene.id, 'text', e.target.value)} 
                                                placeholder="Seslendirilecek metin..." 
                                                className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 min-h-[80px]" 
                                            />
                                        </div>

                                        <div className="space-y-2">
                                            <div>
                                                <label className="text-xs text-gray-400 block mb-1">G√∂rsel URL</label>
                                                <input 
                                                    type="text" 
                                                    value={scene.imageUrl} 
                                                    onChange={(e) => updateScene(scene.id, 'imageUrl', e.target.value)}
                                                    placeholder="https://..."
                                                    className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2"
                                                />
                                            </div>
                                            
                                            <div>
                                                <label className="text-xs text-gray-400 block mb-1">Bilgisayardan Y√ºkle</label>
                                                <input 
                                                    type="file" 
                                                    accept="image/*"
                                                    onChange={(e) => handleImageUpload(scene.id, e)}
                                                    className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm"
                                                />
                                            </div>

                                            <button 
                                                onClick={() => searchImage(scene.id)}
                                                disabled={isGenerating}
                                                className={`w-full ${isGenerating ? 'bg-gray-600' : 'bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700'} py-3 rounded-lg font-bold`}
                                            >
                                                {isGenerating ? '‚è≥ Olu≈üturuluyor...' : 'ü§ñ AI ƒ∞LE G√ñRSEL OLU≈ûTUR'}
                                            </button>

                                            {scene.imageUrl && (
                                                <img 
                                                    src={scene.imageUrl} 
                                                    alt="√ñnizleme" 
                                                    className="w-full h-32 object-cover rounded border-2 border-purple-500" 
                                                />
                                            )}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ViralVideoMaker />);
    </script>
</body>
</html>
